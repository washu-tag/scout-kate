nameOverride: ''
namespaceOverride: ''
ollama:
  # -- Automatically install Ollama Helm chart from https://otwld.github.io/ollama-helm/. Use [Helm Values](https://github.com/otwld/ollama-helm/#helm-values) to configure
  enabled: true
  # -- If enabling embedded Ollama, update fullnameOverride to your desired Ollama name value, or else it will use the default ollama.name value from the Ollama chart
  fullnameOverride: ollama
  ollama:
    gpu:
      enabled: true
      type: 'nvidia'
      number: 1
    models:
      pull: []  # Models are pulled asynchronously via separate Job to avoid Helm timeout
  resources: {{ ollama_resources_default | combine(ollama_resources | default({}), recursive=true) | to_json }}
{% if ollama_min_gpu_memory_gb | int > 0 %}
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: nvidia.com/gpu.memory
                operator: Gt
                values:
                  - '{{ ollama_min_gpu_memory_gb }}'
{% endif %}
  extraEnv:
    - name: OLLAMA_KEEP_ALIVE
      value: '-1'
{% if air_gapped | default(false) and ollama_nfs_path is defined and ollama_nfs_path | length > 0 %}
    # Air-gapped with NFS: mount pre-staged models read-only (ADR 0008)
    - name: OLLAMA_MODELS
      value: '{{ ollama_nfs_mount_path }}'
    - name: OLLAMA_NOPRUNE
      value: 'true'
  volumes:
    - name: nfs-models
      hostPath:
        path: '{{ ollama_nfs_path }}'
        type: Directory
  volumeMounts:
    - name: nfs-models
      mountPath: '{{ ollama_nfs_mount_path }}'
      readOnly: true
  # Disable PVC for models when using NFS
  persistentVolume:
    enabled: false
  # Disable Helm's httpGet liveness probe - we replace it with an exec probe
  # that checks NFS mount accessibility (see deploy.yaml post-Helm patch)
  livenessProbe:
    enabled: false
{% else %}
  # Online: use PVC for models
  persistentVolume:
    enabled: true
{% if ollama_storage_class is defined and ollama_storage_class %}
    storageClass: '{{ ollama_storage_class }}'
{% endif %}
    size: {{ ollama_storage_size }}
{% endif %}
{% if scout_model_create %}
  # Load Scout model into memory on pod startup (if present)
  # Runs in background to avoid blocking pod readiness
  lifecycle:
    postStart:
      exec:
        command:
          - /bin/sh
          - -c
          - |
            (
              # Wait for Ollama API to be ready (poll every 5s, timeout after 60s)
              for i in $(seq 1 12); do
                ollama list >/dev/null 2>&1 && break
                sleep 5
              done
              # Load model into memory if present
              if ollama list 2>/dev/null | grep -q "{{ scout_model_name }}"; then
                echo "Loading Scout model {{ scout_model_name }} into memory..."
                ollama run "{{ scout_model_name }}" "hi" || true
              fi
            ) &
{% endif %}

pipelines:
  enabled: false

ingress:
  enabled: true
  class: traefik
  annotations:
    # Middleware order matters for CSP:
    # 1. Error first: catches 401 and serves sign_in page (bypasses CSP)
    # 2. Auth second: checks authentication
    # 3. CSP third: sets stricter CSP for Open WebUI (overrides global baseline)
    # 4. Security headers last: sets baseline security headers for all responses
    traefik.ingress.kubernetes.io/router.middlewares: >-
      kube-system-oauth2-proxy-error@kubernetescrd,
      kube-system-oauth2-proxy-auth@kubernetescrd{% if open_webui_csp_enabled %},
      {{ chatbot_namespace }}-open-webui-csp@kubernetescrd{% endif %},
      kube-system-security-headers@kubernetescrd
  host: chat.{{ server_hostname }}

persistence:
  enabled: true
{% if open_webui_storage_class is defined and open_webui_storage_class %}
  storageClass: '{{ open_webui_storage_class }}'
{% endif %}
  size: {{ open_webui_storage_size }}

resources: {{ open_webui_resources_default | combine(open_webui_resources | default({}), recursive=true) | to_json }}

# -- Configure database URL, needed to work with Postgres (example: `postgresql://<user>:<password>@<service>:<port>/<database>`), leave empty to use the default sqlite database
databaseUrl: 'postgresql://{{ open_webui_postgres_user }}:{{ open_webui_postgres_password }}@{{ db_host }}:{{ db_port }}/{{ open_webui_database }}'

enableOpenaiApi: false

websocket:
  # -- Enables websocket support in Open WebUI with env `ENABLE_WEBSOCKET_SUPPORT`
  enabled: true
  # Use external Redis for websocket coordination
  manager: redis
  # Set to empty - will be overridden by extraEnvVars below (which comes last in env list)
  url: ''
  redis:
    # Disable embedded Redis - using external Redis Enterprise Database
    enabled: false

# Load sensitive environment variables from Kubernetes Secret
# Secret contains: WEBUI_SECRET_KEY, OAUTH_CLIENT_SECRET, REDIS_URL
extraEnvFrom:
  - secretRef:
      name: open-webui-secrets

# OAuth/OIDC Configuration for Keycloak integration
# OAuth2 Proxy provides initial authentication gate (checks scout-user group)
# Open WebUI's OIDC handles login and role mapping to admin/user roles
# Note: WEBUI_SECRET_KEY and OAUTH_CLIENT_SECRET are loaded from secret above
# REDIS_URL and WEBSOCKET_REDIS_URL are loaded from secret via valueFrom below
extraEnvVars:
  # Disable local authentication (email/password)
  - name: ENABLE_SIGNUP
    value: 'false'

  - name: ENABLE_LOGIN_FORM
    value: 'false'

  # Disable share to OpenWebUI community
  - name: ENABLE_COMMUNITY_SHARING
    value: 'false'

  # Enable OAuth signup and authentication
  - name: ENABLE_OAUTH_SIGNUP
    value: 'true'

  # OAuth provider configuration
  - name: OAUTH_PROVIDER_NAME
    value: '{{ oauth_provider_name }}'

  # OAuth client credentials
  - name: OAUTH_CLIENT_ID
    value: '{{ keycloak_open_webui_client_id }}'

  # OIDC endpoints (uses Keycloak well-known configuration)
  - name: OPENID_PROVIDER_URL
    value: '{{ keycloak_wellknown_url }}'

  # OAuth redirect URI
  - name: OPENID_REDIRECT_URI
    value: '{{ open_webui_callback_url }}'

  # OAuth scopes
  - name: OAUTH_SCOPES
    value: 'openid email profile'

  # Merge accounts by email
  - name: OAUTH_MERGE_ACCOUNTS_BY_EMAIL
    value: 'true'

  # Web UI URL (required for OAuth in clustered environments)
  - name: WEBUI_URL
    value: 'https://chat.{{ server_hostname }}'

  # Enable role management
  - name: ENABLE_OAUTH_ROLE_MANAGEMENT
    value: 'true'

  # Role claim path (uses 'groups' claim from microprofile-jwt scope which includes
  # all client roles and is present in both access and ID tokens)
  - name: OAUTH_ROLES_CLAIM
    value: 'groups'

  # Allowed roles (users with these roles can log in)
  - name: OAUTH_ALLOWED_ROLES
    value: 'open-webui-user,open-webui-admin'

  # Admin roles
  - name: OAUTH_ADMIN_ROLES
    value: 'open-webui-admin'

  # Allow OAuth config updates via env vars (not persistent in DB)
  - name: ENABLE_OAUTH_PERSISTENT_CONFIG
    value: 'false'

  # Logout redirect URL (OAuth2 Proxy signout)
  - name: WEBUI_AUTH_SIGNOUT_REDIRECT_URL
    value: '{{ oauth2_proxy_signout_url }}'

  # Redis URLs with passwords - loaded from secret
  # These override the chart's default WEBSOCKET_REDIS_URL (last env wins)
  - name: WEBSOCKET_REDIS_URL
    valueFrom:
      secretKeyRef:
        name: open-webui-secrets
        key: REDIS_URL
  - name: REDIS_URL
    valueFrom:
      secretKeyRef:
        name: open-webui-secrets
        key: REDIS_URL
